def findBestMoveMiniMaxABTTID(gs, possibleMoves):
    nextMove = [None, 0]
    alpha = -townCost*10
    beta = townCost*10
    transpositionTable = defaultdict(list)
    startTime = time.time()
    previousDepthSearchResult = None
    previousDepthSearchTerminated = [False]

    for currentMaxDepth in range(5, 6):
        print("NEXT MOVE ", nextMove[0])
        # if startTime - time.time() > secondsPerDepth:
        #     print("exited at depth: ", currentMaxDepth - 1)
        #     break

    possibleMoves = gs.getAllPossbileMoves()
    random.shuffle(possibleMoves)
    possibleMoves.sort()

        if nextMove[0] != None:
            print("inserted")
            previousDepthSearchResult = nextMove[0]
            possibleMovesUpdated = [previousDepthSearchResult]
            print("previousDepthSearchResult", previousDepthSearchResult)
            for move in possibleMoves:
                if str(move) == str(previousDepthSearchResult):
                    print("found copy")
                    continue
                possibleMovesUpdated.append(move)

            possibleMoves = possibleMovesUpdated

    findBestMoveMiniMaxABTTIDHelper(
        gs, possibleMoves, 5, gs.redToMove, nextMove, alpha, beta, transpositionTable)

    print("visited node number: ", nextMove[1])
    print("execution time: ", time.time() - startTime)
    print(nextMove[0])
    return nextMove[0]


